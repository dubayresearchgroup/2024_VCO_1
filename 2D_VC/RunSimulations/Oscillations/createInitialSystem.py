import numpy as np
import matplotlib.pyplot as plt

def Triangle(parts, edgeL, ort, x, y):

    ppe = int(parts / 3)
    space = edgeL / ppe
    rTri = edgeL * 3**0.5 / 6
    r = np.linspace(space, edgeL, ppe) - edgeL / 2

    data = np.empty((parts, 4))
    for edge in range(3):

        a = edge * ppe
        b = (edge + 1) * ppe
        shift = edge * np.radians(120)
        data[a:b, 1] = x + r*np.cos(ort + shift) + rTri*np.sin(ort + shift)
        data[a:b, 2] = y + r*np.sin(ort + shift) - rTri*np.cos(ort + shift)

    data[:, 0] = 2
    data[ppe:-1, 0] = 1
    data[2*ppe - 1, 0] = 3
    data[:, 3] = 0.0
 #   print(data)

    return data

def Triangles(tris, parts, edgeL, ort, x, y):
    #MAkes a random distribution of triangles
    tot = tris * parts
    data = np.empty((tot, 5))
    
    for i in range(tris):

        i1 = i*parts
        i2 = (i+1)*parts
        
        data[i1:i2, 1:] = Triangle(parts, edgeL, ort[i], x[i], y[i])
        data[i1:i2, 0] = i + 1

    return data

def Capsid(sigma, parts, edgeL, ort0, x, y, count):
    #Returns a single capsids (6 triangles)
    tris = 6
    tot = tris * parts
    ort = np.linspace(2*np.pi / tris, 2*np.pi, tris) + ort0
    r = edgeL / 3**0.5 + sigma / (2*np.sin(np.pi / tris))

    x = x + r*np.sin(ort)
    y = y - r*np.cos(ort)

    data = np.empty((tot, 6))
    data[:, 1:] = Triangles(tris, parts, edgeL, ort, x, y)
    data[:, 1] += count * tris
    data[:, 0] = np.arange(tot) + 1
    
    return data

def CapsRandom(caps, boxL, sigma, parts, edgeL, seed):
    #returns a box of randomly placed capsids depending on how many you ask for
    np.random.seed(seed)
    tot = caps * parts * 6
    space = 2*edgeL + 3*sigma
    rows = int(boxL / space) - 2
    grid = np.linspace(space, boxL - space, rows)

    full = [('x', 'y')]
    data = np.empty((tot, 6))
    for i in range(caps):
        
        xy = ('x', 'y')
        while xy in full:
            
            x = np.random.choice(grid)
            y = np.random.choice(grid)
            xy = (x, y)
            
        full.append(xy)
        
        i1 = i*parts*6
        i2 = (i+1)*parts*6
        ort = np.random.uniform(0, 2 * np.pi)
        data[i1:i2, :] = Capsid(sigma, parts, edgeL, ort, x, y, i)

    data[:, 0] = np.arange(tot) + 1

    return data

def AntiAlign(sigma, parts, edgeL, tris, ort, x, y):

    tot = tris * parts
    rTri = edgeL * 3**0.5 / 6
    hTri = edgeL * 3**0.5 / 2
    length = (sigma + edgeL/2) * (tris - 1)
    
    x0 = np.linspace(-length/2, length/2, tris)
    y0 = np.tile([-hTri/2 + rTri, hTri/2 - rTri], tris)
    r = (x0**2 + y0[:tris]**2)**0.5
    rOrt = np.arctan2(y0[:tris], x0)
    
    x = x + r*np.cos(rOrt + ort)
    y = y + r*np.sin(rOrt + ort)
    orts = np.tile([0, np.pi], tris) + ort
    
    data = np.empty((tot, 6))
    data[:, 1:] = Triangles(tris, parts, edgeL, orts, x, y)
    data[:, 0] = np.arange(tot) + 1
        
    return data

def AggrRandom(tris, parts, edgeL, seed):

    maxL = int(tris/10)
    lengths = np.arange(3, maxL, 1)

    aggTris = 0
    aggs = []
    while aggTris < tris:
    
        aggs.append(np.random.choice(lengths))

    return

def Random(tris, boxL, sigma, parts, edgeL, seed):
    #Returns a random system of triangles
    np.random.seed(seed)
    tot = tris * parts
    space = edgeL + 2*sigma
    rows = int(boxL / space) - 2
    grid = np.linspace(space, boxL - space, rows)

    full = [('x', 'y')]
    data = np.empty((tot, 6))
    for i in range(tris):

        xy = ('x', 'y')
        while xy in full:
            
            x = np.random.choice(grid)
            y = np.random.choice(grid)
            xy = (x, y)
          #  print(x,y)
            
        full.append(xy)

        i1 = i*parts
        i2 = (i+1)*parts
        ort = np.random.uniform(0, 360)
        data[i1:i2, 2:] = Triangle(parts, edgeL, ort, x, y)
        data[i1:i2, 1] = i + 1

    data[:, 0] = np.arange(tot) + 1
    
    return data

##Details for setting up system
file = 'random'
seed = 46783
 

volFrac = 0.1
tris = 150
caps = int(tris / 6)

edgeL = 1
parts = 15
sigma = 0.25

areaTri = 3**0.5 / 4 * edgeL**2
boxL = (tris * areaTri / volFrac)**(1 / 2)



#### Select what kind of structures you want to be generated by running script 

#data = Capsid(sigma, parts, edgeL, 70, boxL/2, boxL/2, 1)
#data = CapsRandom(caps, boxL, sigma, parts, edgeL, seed)
#data = AntiAlign(sigma, parts, edgeL, tris, np.pi/4, boxL/2, boxL/2)

data = Random(tris, boxL, sigma, parts, edgeL, seed)


    

data[:, 3:5][data[:, 3:5]<0] += boxL
data[:, 3:5][data[:, 3:5]>boxL] -= boxL

##IF you want to visualize with matplotlib what you created, uncomment below: 

# plt.scatter(data[:, 3], data[:, 4], s = 5)
# plt.xlabel('x')
# plt.ylabel('y')
# plt.xticks(np.arange(0, boxL, int(boxL/5)))
# plt.yticks(np.arange(0, boxL, int(boxL/5)))
# plt.title('Random Initialization of Dispersed Triangles')
# plt.savefig('%s.png' % file)
# plt.show()



## Below this section writes a data file containing the positions of the different triangles
lammps = open('%s_%s' % (file, seed), 'w')

lammps.write(
    
f'''# atomPositions
            
{tris * parts} atoms
3 atom types
0 {boxL:.5f} xlo xhi
0 {boxL:.5f} ylo yhi

Masses

1 1.0
2 1.0
3 1.0
             
Atoms
''')   

for line in data:

    line[3] = f'{line[3]:.4f}'
    line[4] = f'{line[4]:.4f}'
    
    aline = ' '.join(str(int(i)) for i in line[:3])
    bline = ' '.join(str(i) for i in line[3:])
    part = ' '.join((aline, bline))
    lammps.write('\n' + part)
    
lammps.close()






